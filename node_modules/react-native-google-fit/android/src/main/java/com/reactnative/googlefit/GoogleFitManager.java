package com.reactnative.googlefit;

import android.app.Activity;
import android.content.Intent;
import android.content.IntentSender;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.util.Log;

import com.facebook.react.bridge.ActivityEventListener;
import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.modules.core.DeviceEventManagerModule;
import com.google.android.gms.common.ConnectionResult;
import com.google.android.gms.common.Scopes;
import com.google.android.gms.common.api.GoogleApiClient;
import com.google.android.gms.common.api.ResultCallback;
import com.google.android.gms.common.api.Scope;
import com.google.android.gms.common.api.Status;
import com.google.android.gms.fitness.Fitness;
import com.google.android.gms.fitness.data.DataType;
import com.google.android.gms.fitness.data.DataSource;
import com.google.android.gms.fitness.request.DataReadRequest;

public class GoogleFitManager implements GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListener, ActivityEventListener {
    private ReactContext mReactContext;
    private GoogleApiClient mApiClient;
    private static final int REQUEST_OAUTH = 1;
    private static final String AUTH_PENDING = "auth_state_pending";
    private boolean authInProgress = false;
    private Activity activity;

    private static final String TAG = "GoogleFitManager";

    public GoogleFitManager(ReactContext reactContext, Activity activity) {
        this.mReactContext = reactContext;
        this.activity = activity;
        mReactContext.addActivityEventListener(this);
    }

    public GoogleApiClient getGoogleApiClient() {
        return mApiClient;
    }

    public WritableArray getAggregatedStepsByDays(long startTime, long endTime) {
        DataSource ESTIMATED_STEP_DELTAS = new DataSource.Builder()
            .setDataType(DataType.TYPE_STEP_COUNT_DELTA)
            .setType(DataSource.TYPE_DERIVED)
            .setStreamName("estimated_steps")
            .setAppPackageName("com.google.android.gms")
            .build();

        DataReadRequest readRequest = QueryAggregator.queryData(startTime, endTime, ESTIMATED_STEP_DELTAS,  DataType.AGGREGATE_STEP_COUNT_DELTA);
        WritableArray dataItems = QueryAggregator.getAggregatedDataByDays(mApiClient, startTime, endTime, readRequest, "int");
        return dataItems;
    }
    
    public WritableArray getAggregatedCaloriesByDays(long startTime, long endTime) {
        DataReadRequest readRequest = QueryAggregator.queryData(startTime, endTime, DataType.TYPE_CALORIES_EXPENDED, DataType.AGGREGATE_CALORIES_EXPENDED);
        WritableArray dataItems = QueryAggregator.getAggregatedDataByDays(mApiClient, startTime, endTime, readRequest, "float");
        return dataItems;
    }

    public WritableArray getAggregatedDistanceByDays(long startTime, long endTime) {
        DataReadRequest readRequest = QueryAggregator.queryData(startTime, endTime, DataType.TYPE_DISTANCE_DELTA, DataType.AGGREGATE_DISTANCE_DELTA);
        WritableArray dataItems = QueryAggregator.getAggregatedDataByDays(mApiClient, startTime, endTime, readRequest, "float");
        return dataItems;
    }

    public WritableArray getAggregatedActiveTimeByDays(long startTime, long endTime) {
        DataReadRequest readRequest = QueryAggregator.queryData(startTime, endTime, DataType.TYPE_ACTIVITY_SEGMENT, DataType.AGGREGATE_ACTIVITY_SUMMARY);
        WritableArray dataItems = QueryAggregator.getAggregatedDataByDays(mApiClient, startTime, endTime, readRequest, "int");
        return dataItems;
    }

    public void authorize() {
        mApiClient = new GoogleApiClient.Builder(mReactContext.getApplicationContext())
                .addApi(Fitness.RECORDING_API)
                .addApi(Fitness.HISTORY_API)
                .addScope(new Scope(Scopes.FITNESS_ACTIVITY_READ))
                .addConnectionCallbacks(this)
                .addOnConnectionFailedListener(this)
                .build();

        mApiClient.connect();
    }

    @Override
    public void onConnected(@Nullable Bundle bundle) {
        //Log.i(TAG, "Connected");
        subscribe();
        WritableMap map = Arguments.createMap();
        map.putBoolean("authorized", true);
        sendEvent(this.mReactContext, "AuthorizeEvent", map);
    }

    //Record step data by requesting a subscription to background step data.
    public void subscribe() {
        DataType[] dataTypes = {
                DataType.TYPE_STEP_COUNT_DELTA,
                DataType.TYPE_CALORIES_EXPENDED,
                DataType.TYPE_DISTANCE_DELTA,
                DataType.TYPE_ACTIVITY_SEGMENT
        };

        for (DataType dataType : dataTypes) {
            Fitness.RecordingApi.subscribe(mApiClient, dataType).setResultCallback(new ResultCallback<Status>() {
                @Override
                public void onResult(Status status) {

                }
            });
        }
    }

    @Override
    public void onConnectionSuspended(int i) {
        //Log.i("AuthorizationMgr", "Connection Suspended");
        if ((mApiClient != null) && (mApiClient.isConnected())) {
            mApiClient.disconnect();
        }
    }

    public boolean isAuthorize() {
        if (mApiClient != null && mApiClient.isConnected()) {
            return true;
        } else {
            return false;
        }
    }

    @Override
    public void onConnectionFailed(@NonNull ConnectionResult connectionResult) {
        //Log.i(TAG, "Failed Authorization Mgr:" + connectionResult);
        if (!authInProgress) {
            try {
                authInProgress = true;
                connectionResult.startResolutionForResult(this.activity, REQUEST_OAUTH);
            } catch (IntentSender.SendIntentException e) {
                Log.i(TAG, "Failed again: " + e);
            }
        }// else {
        //Log.i(TAG, "authInProgress");
        //}
    }

    private void sendEvent(ReactContext reactContext,
                           String eventName,
                           @Nullable WritableMap params) {
        reactContext
                .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
                .emit(eventName, params);
    }


    @Override
    public void onActivityResult(Activity activity, int requestCode, int resultCode, Intent data) {
        //Log.i(TAG, "onActivityResult" + requestCode);
        if (requestCode == REQUEST_OAUTH) {
            authInProgress = false;
            if (resultCode == Activity.RESULT_OK) {
                if (!mApiClient.isConnecting() && !mApiClient.isConnected()) {
                    mApiClient.connect();
                }
            } else if (resultCode == Activity.RESULT_CANCELED) {
                //Log.e(TAG, "RESULT_CANCELED");
                this.authorize();
                //mApiClient.connect();
            }
        } //else {
        //Log.e(TAG, "requestCode NOT request_oauth");
        //}
    }

    @Override
    public void onNewIntent(Intent intent) {

    }
}
